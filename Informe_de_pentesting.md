# Informe sobre vulnerabilidades y mitigaciones en aplicaciones web

## Parte 1: Inyección SQL (SQLi)

La inyección SQL representa una de las vulnerabilidades más críticas en las aplicaciones web. Analizamos varios casos prácticos que ejemplifican los errores comunes y sus posibles soluciones.

### a) Ejemplo de error en una consulta SQL 
Un caso simple de inyección SQL se da cuando los valores ingresados por el usuario no se validan ni se escapan adecuadamente. En un formulario web de la página http://web_vulnerable/insert_player.php, se detectó que, al ingresar " en el campo de usuario, la consulta ejecutada fue:

```sql
SELECT userId, password FROM users WHERE username = """
```

Esto evidencia que los datos provenientes del campo User no están siendo tratados adecuadamente, mientras que el campo password sí está siendo manejado con restricciones.

### b) Ataque por diccionario sin conocer el usuario
Este tipo de ataque consiste en utilizar un diccionario de contraseñas para intentar acceder a una cuenta, incluso sin saber el nombre de usuario. Por ejemplo, con el campo de usuario " OR 1=1 AND password="1234"-- - y la contraseña 1234, se logra un acceso exitoso. Este ataque resalta la necesidad de implementar validaciones robustas en las entradas y limitar los intentos de login para evitar ataques de fuerza bruta.

### c) Errores de programación
Se identificaron varios problemas relacionados con la programación insegura:

- Uso inadecuado de SQLite3::escapeString: Esta función no protege correctamente contra inyecciones SQL. Es necesario reemplazar su uso por consultas parametrizadas, como:

```php
$query = $db->prepare('SELECT userId, password FROM users WHERE username = :username');
$query->bindValue(':username', $user, SQLITE3_TEXT);
```

- Uso de $_COOKIE para información sensible: Almacenar datos críticos en cookies puede exponer información al atacante. En su lugar, se debe utilizar sesiones:

```php
session_start();
$_SESSION['userId'] = $userId;
```

- Validación inexistente del usuario: No verificar la existencia del usuario permite errores lógicos en la aplicación. La validación correcta sería:

```php
if ($row === false) {
    return FALSE; // Usuario no existe
}
```

- Contraseñas en texto plano: Comparar contraseñas sin cifrar es inseguro. La comparación debe realizarse con:

```sql
if (password_verify($password, $row['password']))
```

### d) Vulnerabilidades en add_comment.php
En el archivo add_comment.php se detectaron dos vulnerabilidades principales:

- Inyección SQL en el parámetro ****id: Esta vulnerabilidad permite modificar la consulta SQL, como en el ejemplo ?id=1; DROP TABLE comments;--. La solución es utilizar consultas parametrizadas:

```php
$playerId = intval($_GET['id']);
$stmt = $db->prepare("SELECT commentId, username, body FROM comments C, users U WHERE C.playerId = :id AND U.userId = C.userId ORDER BY C.playerId DESC");
$stmt->bindValue(':id', $playerId, SQLITE3_INTEGER);
```

- Ataque XSS en campos de la base de datos: Si los campos username o body contienen código malicioso, este se ejecutará en el navegador del usuario. La solución es escapar los datos antes de mostrarlos:

```php
echo "<h4>" . htmlspecialchars($row['username'], ENT_QUOTES, 'UTF-8') . "</h4>";
echo "<p>" . htmlspecialchars($row['body'], ENT_QUOTES, 'UTF-8') . "</p>";
```

## Parte 2: Cross-Site Scripting (XSS)

### a) Ejemplo con alert
Al introducir el mensaje <script>alert("Prueba")</script> en el formulario de http://web_vulnerable/add_comment.php?id=5, se demostró que el código JavaScript se ejecuta, confirmando la existencia de una vulnerabilidad XSS reflejada.

### b) Uso de &amp en URLs
El carácter &amp es una representación alternativa del símbolo & utilizada en HTML para evitar conflictos durante el renderizado de páginas web. Esto asegura que las URLs se procesen correctamente.

### c) Problemas al mostrar comentarios
Se identificaron dos problemas:

- Inyección SQL: El uso directo de valores en consultas, como en:

```php
$query = "SELECT commentId, username, body FROM comments C, users U WHERE C.playerId =".$_GET['id']." AND U.userId = C.userId ORDER BY C.playerId DESC";
```

Este código debe reemplazarse por consultas preparadas para prevenir inyecciones.

- XSS: Mostrar datos sin sanitizar expone a los usuarios a ataques. El código inseguro:

```php
echo "<p>commented: " . $row['body'] . "</p>";
```

debe ser modificado usando htmlspecialchars para escapar los datos.

## Parte 3: Control de acceso, autenticación y sesiones

El control adecuado de acceso y autenticación es fundamental. Se identificaron los siguientes problemas:

- Registro inseguro: No se validan las entradas, se permiten contraseñas débiles y se crean usuarios con privilegios sin restricciones. Para mejorar esto, se deben implementar validaciones estrictas, cifrado de contraseñas y roles diferenciados.

- Login inseguro: No se valida la entrada ni se limita el número de intentos fallidos. Para prevenir ataques de fuerza bruta, es necesario bloquear usuarios tras varios intentos fallidos y usar password_verify para las comparaciones.

- Registros no autenticados: Permitir que cualquier usuario se registre sin autenticación es un riesgo. Se recomienda que solo usuarios autenticados puedan registrar nuevos usuarios y que los administradores validen estas cuentas.

## Parte 4: Seguridad en servidores web

La configuración del servidor web debe garantizar:
- Validación de entradas.
- Cifrado de contraseñas.
- Limitación de intentos de login.
- Implementación de roles de usuario.
- Acceso restringido a archivos sensibles.
- Uso de tokens CSRF para prevenir ataques.

## Parte 5: Cross-Site Request Forgery (CSRF)

### a) Botón de donación malicioso
Se observó un ejemplo de ataque CSRF al insertar el siguiente código en el campo team:

```php
<form action="http://web.pagos/donate.php?amount=100&receiver=attacker" method="get"> <button type="submit">Profile</button> </form>
```

### b) Redirección desde comentarios
En el campo comentario, se introdujo el script:

```php
<script>window.location='http://www.donate.co/?amount=100&destination=ACMEScouting/';</script>
```
Esto demuestra cómo un atacante puede redirigir al usuario a una página maliciosa.

### c) Condiciones para realizar donaciones
Para que el ataque sea efectivo, los usuarios deben estar autenticados en la página. Esto resalta la importancia de validar los tokens CSRF en los formularios.

### d) Ataque alternativo con formulario oculto
Se mostró otro ejemplo de ataque con el siguiente código:

```php
<form action="donate.php" method="POST">
    <input type="hidden" name="amount" value="100">
    <input type="hidden" name="receiver" value="<script>window.location='http://www.donate.co/?amount=100&destination=ACMEScouting/';</script>">
    <input type="submit" value="Realizar donación">
</form>
```

Este informe evidencia la necesidad de implementar buenas prácticas de seguridad en todas las etapas del desarrollo de aplicaciones web para minimizar riesgos y garantizar la integridad y confidencialidad de los datos.

